<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒãƒƒãƒ—ã‚¨ãƒ‡ã‚£ã‚¿ v5.0 (å£åˆ¤å®šå¼·åŒ–)</title>
    <style>
        body { font-family: sans-serif; display: flex; gap: 20px; padding: 20px; background-color: #f4f7f6; height: 95vh; box-sizing: border-box; color: #333; }
        #canvas-wrapper { position: relative; border: 2px solid #ccc; overflow: auto; flex-grow: 1; background: white; box-shadow: 0 4px 6px rgba(0,0,0,0.1); display:flex; justify-content:center; align-items:center; }
        canvas { cursor: default; display: block; }
        #sidebar { width: 340px; display: flex; flex-direction: column; gap: 15px; height: 100%; min-width: 340px; }
        .panel { border: 1px solid #e0e0e0; padding: 15px; border-radius: 8px; background: white; }
        h3 { margin: 0 0 10px 0; font-size: 15px; border-bottom: 2px solid #eee; padding-bottom: 5px; color: #555; }
        input, select, button { padding: 8px; width: 100%; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 8px; font-size: 13px;}
        button { background: #007bff; color: white; border: none; font-weight: bold; cursor: pointer; }
        button:hover { background: #0056b3; }
        button.secondary { background: #6c757d; }
        button.danger { background: #dc3545; }
        button.outline { background: transparent; border: 1px solid #007bff; color: #007bff; }
        .input-group { display: flex; gap: 5px; margin-bottom: 5px; }
        .tabs { display: flex; margin-bottom: 10px; border-bottom: 1px solid #ddd; }
        .tab { flex: 1; padding: 8px; text-align: center; cursor: pointer; background: #f9f9f9; color: #666; border: 1px solid #ddd; margin-right: -1px;}
        .tab.active { background: white; color: #007bff; font-weight: bold; border-top: 2px solid #007bff; border-bottom: 1px solid white;}
        .list-container { flex-grow: 1; overflow-y: auto; border: 1px solid #eee; height: 150px; }
        .list-item { padding: 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px; cursor: pointer; }
        .list-item:hover { background: #f5faff; }
        .list-item.selected { background: #e6f2ff; border-left: 4px solid #007bff; }
        .hidden { display: none; }
        .slider-label { display:flex; justify-content:space-between; font-size:12px; color:#666;}
    </style>
</head>
<body>

    <div id="canvas-wrapper">
        <canvas id="mapCanvas"></canvas>
    </div>

    <div id="sidebar">
        <div class="panel">
            <h3>1. å›³é¢èª­è¾¼</h3>
            <input type="file" id="imageLoader" accept="image/*, .svg">
        </div>

        <div class="panel" style="flex-grow: 1; display: flex; flex-direction: column;">
            <div class="tabs">
                <div class="tab active" onclick="setMode('magic')" id="tabMagic">ğŸª„ è‡ªå‹•ä½œæˆ</div>
                <div class="tab" onclick="setMode('manual')" id="tabManual">ğŸ‘† æ‰‹å‹•ä½œæˆ</div>
            </div>

            <!-- è‡ªå‹•è¨­å®š -->
            <div id="magicSettings">
                <div class="slider-label"><span>éš™é–“åŸ‹ã‚ (å¤ªã‚‰ã›)</span><span id="dilationVal">2</span></div>
                <input type="range" id="dilationRange" min="0" max="10" value="2" oninput="updateDilation(this.value)">
                
                <div class="slider-label"><span>å£ã®è‰²åˆ¤å®šæ„Ÿåº¦</span><span id="thresholdVal">180</span></div>
                <input type="range" id="thresholdRange" min="50" max="240" value="180" onchange="updateDilation(document.getElementById('dilationRange').value)">
                <p style="font-size:11px; color:#666; margin:0 0 5px;">â€»æ„Ÿåº¦ã‚’ä¸Šã’ã‚‹ã¨è–„ã„ç·šã‚‚å£ã¨èªè­˜ã—ã¾ã™(æœ€å¤§240)</p>
            </div>

            <!-- æ‰‹å‹•è¨­å®š -->
            <div id="manualSettings" class="hidden">
                <label><input type="checkbox" id="snapCheck" checked> è¿‘ãã®ç‚¹ã«å¸ç€(ã‚¹ãƒŠãƒƒãƒ—)</label>
            </div>

            <!-- ç·¨é›†ã‚¨ãƒªã‚¢ -->
            <div id="attributeEditor" style="margin-top: 10px; border-top: 1px solid #eee; padding-top: 10px;">
                <h3 id="editorTitle">ã‚¨ãƒªã‚¢è¨­å®š</h3>
                <input type="text" id="roomName" placeholder="åç§° (ä¾‹: 1-A)">
                <select id="roomType">
                    <option value="classroom">æ•™å®¤</option>
                    <option value="hallway">å»Šä¸‹</option>
                    <option value="entrance">å‡ºå…¥å£</option>
                    <option value="stairs">éšæ®µ</option>
                    <option value="restroom_m">ãƒˆã‚¤ãƒ¬(ç”·)</option>
                    <option value="restroom_f">ãƒˆã‚¤ãƒ¬(å¥³)</option>
                    <option value="other">ãã®ä»–</option>
                </select>
                <div id="stairInfo" class="hidden"><input type="text" id="targetFloor" placeholder="æ¥ç¶šéš"></div>

                <div class="input-group" id="createActions">
                    <button class="secondary" onclick="undoPoint()">æˆ»ã‚‹</button>
                    <button onclick="finishArea()">ç¢ºå®š</button>
                </div>
                <div class="input-group hidden" id="editActions">
                    <button onclick="updateSelectedArea()">å¤‰æ›´ä¿å­˜</button>
                    <button class="danger" onclick="deleteSelectedArea()">å‰Šé™¤</button>
                </div>
                <div id="selectionHint" class="hidden" style="font-size:11px; text-align:center; color:#007bff;">é ‚ç‚¹ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã§ä¿®æ­£å¯</div>
            </div>

            <div class="list-container" id="areaList"></div>
        </div>

        <div class="panel">
            <h3>3. å‡ºåŠ›</h3>
            <button class="outline" onclick="exportJSON()">JSONã‚³ãƒ”ãƒ¼</button>
            <textarea id="jsonOutput" style="height: 50px;"></textarea>
        </div>
    </div>

<script>
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    let img = new Image();
    let areas = [];
    let currentPoints = [];
    let mode = 'magic'; 
    let selectedAreaIndex = -1;
    let draggingPointIndex = -1;
    let collisionData = null; // é«˜é€ŸåŒ–ã®ãŸã‚ImageDataé…åˆ—ã‚’ä¿æŒ
    let collisionWidth = 0;

    // --- åˆæœŸåŒ– ---
    document.getElementById('imageLoader').addEventListener('change', function(e){
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = function(event){
            img.onload = function(){
                canvas.width = img.width;
                canvas.height = img.height;
                prepareCollisionMap();
                draw();
            }
            img.src = event.target.result;
        }
    });

    // --- å£åˆ¤å®šãƒãƒƒãƒ—ä½œæˆ (æœ€é‡è¦) ---
    function prepareCollisionMap() {
        if(!img.src) return;
        const dilation = parseInt(document.getElementById('dilationRange').value);
        const threshold = parseInt(document.getElementById('thresholdRange').value);
        document.getElementById('dilationVal').innerText = dilation;
        document.getElementById('thresholdVal').innerText = threshold;

        // ä½œæ¥­ç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹
        const c = document.createElement('canvas');
        c.width = canvas.width;
        c.height = canvas.height;
        const cx = c.getContext('2d');
        
        // ç”»åƒã‚’æç”»
        cx.drawImage(img, 0, 0);

        // 1. ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const imgData = cx.getImageData(0, 0, c.width, c.height);
        const data = imgData.data;
        
        // 2. äºŒå€¤åŒ–å‡¦ç† (ã“ã“ã§é–¾å€¤ã‚’é©ç”¨ã—ã€å£ã‚’é»’(1)ã€åºŠã‚’ç™½(0)ã«ã™ã‚‹é…åˆ—ã‚’ä½œã‚‹)
        // Uint8Arrayã§å£ãƒãƒƒãƒ—ã‚’ä½œã‚‹ (0:åºŠ, 1:å£)
        const walls = new Uint8Array(c.width * c.height);
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i], g = data[i+1], b = data[i+2];
            // æ˜ã‚‹ã•ãŒé–¾å€¤ã‚ˆã‚Šä½ã‘ã‚Œã°ã€Œå£ã€ã¨ã¿ãªã™
            // ç™½ã«è¿‘ã„ã‚°ãƒ¬ãƒ¼(200ã¨ã‹)ã‚‚å£ã«ã™ã‚‹ãŸã‚ã€thresholdã¯é«˜ã‚ã«è¨­å®šã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
            const brightness = (r + g + b) / 3;
            if (brightness < threshold) {
                walls[i / 4] = 1;
            }
        }

        // 3. è†¨å¼µå‡¦ç† (Dilation) - éš™é–“åŸ‹ã‚
        // å£ã®å‘¨å›² dilation ãƒ”ã‚¯ã‚»ãƒ«ã‚‚å£ã«ã™ã‚‹
        if (dilation > 0) {
            const dilatedWalls = new Uint8Array(walls.length);
            const w = c.width;
            const h = c.height;
            
            for(let y=0; y<h; y++) {
                for(let x=0; x<w; x++) {
                    if(walls[y*w + x] === 1) {
                        // å‘¨å›²ã‚’å¡—ã‚Šã¤ã¶ã™
                        for(let dy=-dilation; dy<=dilation; dy++) {
                            for(let dx=-dilation; dx<=dilation; dx++) {
                                const ny = y + dy;
                                const nx = x + dx;
                                if(nx>=0 && nx<w && ny>=0 && ny<h) {
                                    dilatedWalls[ny*w + nx] = 1;
                                }
                            }
                        }
                    }
                }
            }
            collisionData = dilatedWalls;
        } else {
            collisionData = walls;
        }
        collisionWidth = c.width;
        
        // ãƒ‡ãƒãƒƒã‚°ç”¨: åˆ¤å®šçµæœãŒè¦‹ãŸã„å ´åˆã¯ä»¥ä¸‹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤–ã—ã¦canvasã«æç”»
        /*
        const debugImg = cx.createImageData(c.width, c.height);
        for(let i=0; i<collisionData.length; i++) {
            const val = collisionData[i] === 1 ? 0 : 255;
            debugImg.data[i*4] = val; debugImg.data[i*4+1] = val; debugImg.data[i*4+2] = val; debugImg.data[i*4+3] = 255;
        }
        ctx.putImageData(debugImg, 0, 0); // ãƒ¡ã‚¤ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ã«æç”»ã—ã¦ç¢ºèª
        */
    }

    function updateDilation(val) { prepareCollisionMap(); }

    // --- ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ ---
    canvas.addEventListener('mousedown', function(e) {
        let pos = getPos(e);

        // æ‰‹å‹•ãƒ¢ãƒ¼ãƒ‰ã®ã‚¹ãƒŠãƒƒãƒ—æ©Ÿèƒ½
        if (mode === 'manual' && document.getElementById('snapCheck').checked) {
            const snapPos = findNearestPoint(pos);
            if(snapPos) pos = snapPos;
        }

        // A. ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ (é ‚ç‚¹ç§»å‹•)
        if (selectedAreaIndex !== -1) {
            const area = areas[selectedAreaIndex];
            for(let i=0; i<area.points.length; i++) {
                if (dist(area.points[i], pos) < 10) {
                    draggingPointIndex = i;
                    return;
                }
            }
        }

        // B. æ‰‹å‹•ä½œæˆ
        if (mode === 'manual') {
            currentPoints.push(pos);
            draw();
        }
        // C. è‡ªå‹•ä½œæˆ
        else if (mode === 'magic') {
            const clickedIdx = findAreaIndexAt(pos);
            if (clickedIdx !== -1) {
                selectArea(clickedIdx);
            } else {
                startMagicWand(pos);
            }
        }
        // D. é¸æŠè§£é™¤
        else if (mode === 'edit') {
             const clickedIdx = findAreaIndexAt(pos);
             if (clickedIdx !== -1) selectArea(clickedIdx);
             else deselectArea();
        }
    });

    canvas.addEventListener('mousemove', function(e) {
        const pos = getPos(e);
        if (draggingPointIndex !== -1 && selectedAreaIndex !== -1) {
            areas[selectedAreaIndex].points[draggingPointIndex] = pos;
            draw();
        } else {
            // ã‚«ãƒ¼ã‚½ãƒ«å¤‰æ›´
            if (selectedAreaIndex !== -1) {
                const hit = areas[selectedAreaIndex].points.some(p => dist(p, pos) < 10);
                canvas.style.cursor = hit ? 'move' : 'default';
            }
            
            // æ‰‹å‹•ãƒ¢ãƒ¼ãƒ‰ã®ã‚¹ãƒŠãƒƒãƒ—ã‚¬ã‚¤ãƒ‰è¡¨ç¤º
            if(mode === 'manual' && document.getElementById('snapCheck').checked) {
                draw(); // å†æç”»ã—ã¦ã‚¬ã‚¤ãƒ‰ã‚’æ›´æ–°
                const snap = findNearestPoint(pos);
                if(snap) {
                    ctx.strokeStyle = '#00f'; ctx.lineWidth=2; 
                    ctx.strokeRect(snap.x-5, snap.y-5, 10, 10);
                }
            }
        }
    });

    canvas.addEventListener('mouseup', () => draggingPointIndex = -1);
    canvas.addEventListener('dblclick', (e) => {
        if(mode === 'manual') { e.preventDefault(); currentPoints.pop(); finishArea(); }
    });

    // --- è‡ªå‹•æ¤œå‡ºãƒ­ã‚¸ãƒƒã‚¯ (ç²¾åº¦å‘ä¸Šç‰ˆ) ---
    function startMagicWand(pos) {
        if (!collisionData) prepareCollisionMap();
        const w = collisionWidth;
        const h = canvas.height;

        // æŒ‡å®šåº§æ¨™ãŒå£ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯ (å£ãªã‚‰è‡ªå‹•ç”Ÿæˆã—ãªã„)
        if (collisionData[pos.y * w + pos.x] === 1) {
            alert("å£ã®ä¸Šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã„ã¾ã™ã€‚éƒ¨å±‹ã®ä¸­ï¼ˆç™½ã„éƒ¨åˆ†ï¼‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚");
            return;
        }

        const rays = 180; // ãƒ¬ã‚¤ã®æœ¬æ•°ã‚’å¢—ã‚„ã™ (ç²¾åº¦å‘ä¸Š)
        let points = [];
        
        for(let i=0; i<rays; i++) {
            const angle = (i/rays) * Math.PI * 2;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            // 1ãƒ”ã‚¯ã‚»ãƒ«ãšã¤é£›ã°ã™ã¨é…ã„ã®ã§ã€æœ€åˆã¯ç²—ãã€å£ã«è¿‘ã¥ã„ãŸã‚‰ç´°ã‹ãæ¢ç´¢
            let hit = false;
            let r = 0;
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’è¶…ãˆã‚‹ã¾ã§æ¢ç´¢
            const maxDist = Math.max(w, h); 
            
            while(r < maxDist) {
                r += 1; // 1pxåˆ»ã¿ã§é€²ã‚€ï¼ˆã™ã‚ŠæŠœã‘é˜²æ­¢ã®ãŸã‚ç´°ã‹ãï¼‰
                
                const tx = Math.round(pos.x + cos * r);
                const ty = Math.round(pos.y + sin * r);
                
                if(tx<0 || tx>=w || ty<0 || ty>=h) {
                    break; // ç”»é¢å¤–
                }
                
                // å£åˆ¤å®š
                if(collisionData[ty * w + tx] === 1) {
                    points.push({x: tx, y: ty});
                    hit = true;
                    break; 
                }
            }
        }

        // ãƒã‚¤ã‚ºé™¤å»ï¼ˆè¿‘ã™ãã‚‹ç‚¹ã‚’é–“å¼•ãï¼‰
        const cleanPoints = points.filter((p, i) => {
            if(i===0) return true;
            return dist(p, points[i-1]) > 5;
        });

        if(cleanPoints.length > 5) {
            currentPoints = cleanPoints;
            finishArea();
            selectArea(areas.length - 1);
        } else {
            alert("å£ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚æ„Ÿåº¦(å£ã®è‰²åˆ¤å®š)ã‚’ä¸Šã’ã‚‹ã‹ã€æ‰‹å‹•ãƒ¢ãƒ¼ãƒ‰ã‚’è©¦ã—ã¦ãã ã•ã„ã€‚");
        }
    }

    // --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ---
    function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return { x: Math.round((e.clientX - rect.left)*scaleX), y: Math.round((e.clientY - rect.top)*scaleY) };
    }
    function dist(p1, p2) { return Math.hypot(p1.x - p2.x, p1.y - p2.y); }

    // è¿‘ãã®é ‚ç‚¹ã‚’æ¢ã™ (ã‚¹ãƒŠãƒƒãƒ—ç”¨)
    function findNearestPoint(pos) {
        let nearest = null;
        let minD = 15; // ã‚¹ãƒŠãƒƒãƒ—è·é›¢
        // æ—¢å­˜ã‚¨ãƒªã‚¢ã®ç‚¹ã¨ã€ç¾åœ¨ä½œæˆä¸­ã®ç‚¹ã‹ã‚‰æ¢ã™
        const candidates = [...areas.flatMap(a=>a.points), ...currentPoints];
        
        for(const p of candidates) {
            const d = dist(p, pos);
            if(d < minD) { minD = d; nearest = p; }
        }
        return nearest;
    }

    // --- ã‚¨ãƒªã‚¢æ“ä½œ (å…±é€š) ---
    function finishArea() {
        if(currentPoints.length < 3) return;
        const name = document.getElementById('roomName').value || `Area ${areas.length+1}`;
        const type = document.getElementById('roomType').value;
        const floor = document.getElementById('targetFloor').value;
        areas.push({ id: Date.now(), name, type, targetFloor: floor, points: [...currentPoints] });
        currentPoints = [];
        updateList(); draw();
    }

    function selectArea(idx) {
        selectedAreaIndex = idx;
        mode = 'edit';
        const a = areas[idx];
        document.getElementById('roomName').value = a.name;
        document.getElementById('roomType').value = a.type;
        if(a.targetFloor) document.getElementById('targetFloor').value = a.targetFloor;
        
        document.getElementById('createActions').classList.add('hidden');
        document.getElementById('editActions').classList.remove('hidden');
        document.getElementById('selectionHint').classList.remove('hidden');
        updateList(); draw();
    }

    function deselectArea() {
        selectedAreaIndex = -1;
        mode = document.getElementById('tabMagic').classList.contains('active') ? 'magic' : 'manual';
        document.getElementById('createActions').classList.remove('hidden');
        document.getElementById('editActions').classList.add('hidden');
        document.getElementById('selectionHint').classList.add('hidden');
        updateList(); draw();
    }

    function updateSelectedArea() {
        if(selectedAreaIndex===-1)return;
        const a = areas[selectedAreaIndex];
        a.name = document.getElementById('roomName').value;
        a.type = document.getElementById('roomType').value;
        a.targetFloor = document.getElementById('targetFloor').value;
        updateList(); draw();
    }
    function deleteSelectedArea() {
        if(selectedAreaIndex!==-1 && confirm("å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) {
            areas.splice(selectedAreaIndex, 1);
            deselectArea();
        }
    }
    function undoPoint() { currentPoints.pop(); draw(); }

    function updateList() {
        const list = document.getElementById('areaList');
        list.innerHTML = '';
        areas.forEach((a, i) => {
            const d = document.createElement('div');
            d.className = 'list-item'+(i===selectedAreaIndex?' selected':'');
            d.innerText = `${a.name} (${a.type})`;
            d.onclick = () => selectArea(i);
            list.appendChild(d);
        });
    }

    function findAreaIndexAt(pos) {
        for(let i=areas.length-1; i>=0; i--) {
            const pts = areas[i].points;
            let inside = false;
            for (let j = 0, k = pts.length - 1; j < pts.length; k = j++) {
                if (((pts[j].y > pos.y) !== (pts[k].y > pos.y)) && (pos.x < (pts[k].x - pts[j].x) * (pos.y - pts[j].y) / (pts[k].y - pts[j].y) + pts[j].x)) inside = !inside;
            }
            if(inside) return i;
        }
        return -1;
    }

    // --- æç”» ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (img.src) ctx.drawImage(img, 0, 0);
        
        areas.forEach((a, i) => {
            const sel = (i === selectedAreaIndex);
            drawPoly(a.points, getColor(a.type), true, sel);
            // ãƒ©ãƒ™ãƒ«
            const c = getCenter(a.points);
            ctx.fillStyle = "black"; ctx.font="12px Arial"; ctx.textAlign="center"; ctx.fillText(a.name, c.x, c.y);
            
            if(sel) {
                a.points.forEach(p => {
                    ctx.fillStyle='white'; ctx.strokeStyle='#007bff'; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                });
            }
        });
        if(currentPoints.length>0) drawPoly(currentPoints, 'red', false, false);
    }

    function drawPoly(pts, color, fill, highlight) {
        if(!pts.length)return;
        ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
        for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
        ctx.closePath();
        if(fill){ ctx.fillStyle=color; ctx.fill(); }
        ctx.strokeStyle = highlight ? '#007bff' : '#666';
        ctx.lineWidth = highlight ? 3 : 1;
        ctx.stroke();
    }

    function getColor(type) {
        const c = { 'classroom':'#4CAF5066', 'hallway':'#FFC10766', 'entrance':'#2196F366', 'stairs':'#9C27B066', 'restroom_m':'#3F51B580', 'restroom_f':'#E91E6380' };
        return c[type] || '#9E9E9E66';
    }
    function getCenter(pts) { let x=0,y=0; pts.forEach(p=>{x+=p.x;y+=p.y}); return {x:x/pts.length, y:y/pts.length}; }
    
    function setMode(m) {
        deselectArea(); mode = m;
        document.getElementById('tabMagic').className = m === 'magic' ? 'tab active' : 'tab';
        document.getElementById('tabManual').className = m === 'manual' ? 'tab active' : 'tab';
        document.getElementById('magicSettings').style.display = m === 'magic' ? 'block' : 'none';
        document.getElementById('manualSettings').style.display = m === 'manual' ? 'block' : 'none';
    }
    window.exportJSON = () => { 
        const j = JSON.stringify(areas.map(({id,...r})=>r), null, 2);
        document.getElementById('jsonOutput').value = j;
        navigator.clipboard.writeText(j).then(()=>alert("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ"));
    };
    document.getElementById('roomType').addEventListener('change', (e)=> document.getElementById('stairInfo').classList.toggle('hidden', e.target.value!=='stairs'));
</script>
</body>
</html>
