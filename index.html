<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒãƒƒãƒ—ã‚¨ãƒ‡ã‚£ã‚¿ v7.1 (åˆ¤å®šæ”¹è‰¯)</title>
    <style>
        body { font-family: sans-serif; display: flex; gap: 20px; padding: 20px; background-color: #f4f7f6; height: 95vh; box-sizing: border-box; color: #333; }
        #canvas-wrapper { position: relative; border: 2px solid #ccc; overflow: hidden; flex-grow: 1; background: white; box-shadow: 0 4px 6px rgba(0,0,0,0.1); display:flex; justify-content:center; align-items:center; }
        canvas { display: block; }
        #sidebar { width: 340px; display: flex; flex-direction: column; gap: 15px; height: 100%; min-width: 340px; }
        .panel { border: 1px solid #e0e0e0; padding: 15px; border-radius: 8px; background: white; }
        h3 { margin: 0 0 10px 0; font-size: 15px; border-bottom: 2px solid #eee; padding-bottom: 5px; color: #555; }
        input, select, button { padding: 8px; width: 100%; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 8px; font-size: 13px;}
        button { background: #007bff; color: white; border: none; font-weight: bold; cursor: pointer; }
        button:hover { background: #0056b3; }
        button.secondary { background: #6c757d; }
        button.danger { background: #dc3545; }
        button.magic { background: #6610f2; }
        .input-group { display: flex; gap: 5px; margin-bottom: 5px; }
        .list-container { flex-grow: 1; overflow-y: auto; border: 1px solid #eee; height: 150px; }
        .list-item { padding: 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px; cursor: pointer; }
        .list-item:hover { background: #f5faff; }
        .list-item.selected { background: #e6f2ff; border-left: 4px solid #007bff; }
        .hidden { display: none; }
        .slider-label { display:flex; justify-content:space-between; font-size:12px; color:#666; margin-bottom:2px;}
        .debug-view { font-size:11px; color:#666; margin-top:5px; display:block;}
    </style>
</head>
<body>

    <div id="canvas-wrapper">
        <canvas id="mapCanvas"></canvas>
    </div>

    <div id="sidebar">
        <div class="panel">
            <h3>1. å›³é¢èª­è¾¼</h3>
            <input type="file" id="imageLoader" accept="image/*, .svg">
        </div>

        <div class="panel" style="flex-grow: 1; display: flex; flex-direction: column;">
            <h3>2. è‡ªå‹•æ¤œå‡ºè¨­å®š</h3>
            
            <div class="slider-label"><span>éš™é–“åŸ‹ã‚ãƒ¬ãƒ™ãƒ«</span><span id="gapVal">5</span></div>
            <input type="range" id="gapRange" min="0" max="20" value="5" oninput="updateSettings(this.value)">
            <small style="color:#666; font-size:11px; margin-bottom:5px; display:block;">
                å€¤ã‚’ä¸Šã’ã‚‹ã¨å£ãŒå¤ªããªã‚Šéš™é–“ãŒåŸ‹ã¾ã‚Šã¾ã™ã€‚<br>
                <span style="color:red;">â€»ã‚¯ãƒªãƒƒã‚¯ã§ããªã„å ´åˆã¯å€¤ã‚’ä¸‹ã’ã¦ãã ã•ã„ã€‚</span>
            </small>

            <label class="debug-view">
                <input type="checkbox" id="showDebug" onchange="draw()"> 
                è§£æç”¨ã®ã€Œå¤ªã£ãŸå£ã€ã‚’è¡¨ç¤ºã™ã‚‹
            </label>

            <hr style="border:0; border-top:1px solid #eee; width:100%; margin:10px 0;">

            <div id="actionPanel">
                 <button class="magic" onclick="autoDetect()">âš¡ å…¨ã‚¨ãƒªã‚¢ä¸€æ‹¬æ¤œå‡º</button>
                 <p style="text-align:center; margin:5px 0; font-size:12px; color:#888;">ã¾ãŸã¯ã€å›³é¢ä¸Šã®éƒ¨å±‹ã‚’ã‚¯ãƒªãƒƒã‚¯</p>
                 <button class="secondary" onclick="setMode('manual')">ğŸ– æ‰‹å‹•ã§æã</button>
            </div>

            <div id="attributeEditor" class="hidden" style="margin-top: 10px; border-top: 1px solid #eee; padding-top: 10px;">
                <h3 style="font-size:13px;">é¸æŠã‚¨ãƒªã‚¢ã®ç·¨é›†</h3>
                <input type="text" id="roomName" placeholder="åç§° (ä¾‹: 1-A)">
                <select id="roomType">
                    <option value="classroom">æ•™å®¤</option>
                    <option value="hallway">å»Šä¸‹</option>
                    <option value="entrance">å‡ºå…¥å£</option>
                    <option value="stairs">éšæ®µ</option>
                    <option value="restroom_m">ãƒˆã‚¤ãƒ¬(ç”·)</option>
                    <option value="restroom_f">ãƒˆã‚¤ãƒ¬(å¥³)</option>
                    <option value="other">ãã®ä»–</option>
                </select>
                <div class="input-group">
                    <button onclick="updateSelectedArea()">æ›´æ–°</button>
                    <button class="danger" onclick="deleteSelectedArea()">å‰Šé™¤</button>
                </div>
            </div>

            <div class="list-container" id="areaList"></div>
        </div>

        <div class="panel">
            <h3>3. å‡ºåŠ›</h3>
            <button class="secondary" onclick="exportJSON()">JSONã‚³ãƒ”ãƒ¼</button>
            <textarea id="jsonOutput" style="height: 50px;"></textarea>
        </div>
    </div>

<script>
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    let img = new Image();
    let areas = [];
    let currentPoints = []; 
    let mode = 'auto'; 
    let selectedAreaIndex = -1;
    
    let processingCanvas = document.createElement('canvas');
    let pCtx = processingCanvas.getContext('2d', { willReadFrequently: true });

    document.getElementById('imageLoader').addEventListener('change', function(e){
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = function(event){
            img.onload = function(){
                canvas.width = img.width;
                canvas.height = img.height;
                processingCanvas.width = img.width;
                processingCanvas.height = img.height;
                prepareProcessingMap();
                draw();
            }
            img.src = event.target.result;
        }
    });

    function prepareProcessingMap() {
        if(!img.src) return;
        const gapSize = parseInt(document.getElementById('gapRange').value);
        document.getElementById('gapVal').innerText = gapSize;

        pCtx.clearRect(0, 0, processingCanvas.width, processingCanvas.height);
        pCtx.drawImage(img, 0, 0);
        
        // éš™é–“åŸ‹ã‚å‡¦ç†
        if (gapSize > 0) {
            pCtx.save();
            pCtx.filter = `blur(${gapSize/2}px)`; // ã¼ã‹ã—
            pCtx.drawImage(processingCanvas, 0, 0);
            pCtx.filter = `contrast(5000%) grayscale(100%)`; // äºŒå€¤åŒ–ã—ã¦å¤ªã‚‰ã›ã‚‹
            pCtx.drawImage(processingCanvas, 0, 0);
            pCtx.restore();
        }
    }

    function updateSettings(val) {
        prepareProcessingMap();
        if(document.getElementById('showDebug').checked) draw();
    }

    canvas.addEventListener('mousedown', async function(e) {
        const pos = getPos(e);

        if (mode === 'manual') {
            currentPoints.push(pos);
            draw();
            return;
        }

        const clickedIdx = findAreaIndex(pos);
        if (clickedIdx !== -1) {
            selectArea(clickedIdx);
            return;
        }
        
        if (mode === 'auto') {
            detectRoomAt(pos.x, pos.y);
        }
        
        selectedAreaIndex = -1;
        document.getElementById('attributeEditor').classList.add('hidden');
        draw();
    });
    
    canvas.addEventListener('dblclick', function() {
        if(mode === 'manual' && currentPoints.length > 2) {
            addArea(currentPoints, 'manual');
            currentPoints = [];
            draw();
        }
    });

    // --- åˆ¤å®šå¼·åŒ–ç‰ˆ Flood Fill ---
    function detectRoomAt(startX, startY) {
        const w = processingCanvas.width;
        const h = processingCanvas.height;

        // A. å…ƒç”»åƒã§ã®ãƒã‚§ãƒƒã‚¯ (è¦‹ãŸç›®ãŒç™½ã‘ã‚Œã°è¨±å¯ã™ã‚‹)
        const originalData = ctx.getImageData(startX, startY, 1, 1).data;
        const isOriginalBlack = (originalData[0] < 100 && originalData[1] < 100 && originalData[2] < 100);
        
        if (isOriginalBlack) {
             // å…ƒç”»åƒã‚‚çœŸã£é»’ãªã‚‰æœ¬å½“ã«å£
             alert("å£ã®ä¸Šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã„ã¾ã™ã€‚");
             return;
        }

        // B. éš™é–“åŸ‹ã‚ãƒãƒƒãƒ—ã§ã®ãƒã‚§ãƒƒã‚¯
        const procData = pCtx.getImageData(startX, startY, 1, 1).data;
        let useX = startX, useY = startY;
        
        // ã‚‚ã—éš™é–“åŸ‹ã‚ãƒãƒƒãƒ—ã§ã¯ã€Œå£(é»’)ã€ã«ãªã£ã¦ã„ã‚‹å ´åˆã€
        // ã€Œéš™é–“åŸ‹ã‚å¼·åº¦ãŒå¼·ã™ãã¦éƒ¨å±‹ãŒã¤ã¶ã‚Œã¦ã„ã‚‹ã€ã‹ã€Œã‚¯ãƒªãƒƒã‚¯ä½ç½®ãŒå£éš›ã™ãã‚‹ã€
        if (procData[0] < 128) {
            // ãƒªã‚«ãƒãƒªãƒ¼: åŠå¾„10pxä»¥å†…ã§ã€Œéš™é–“åŸ‹ã‚ãƒãƒƒãƒ—ã§ã‚‚ç™½ã„å ´æ‰€ã€ã‚’æ¢ã™
            let found = false;
            for(let r=1; r<=10; r++) {
                for(let ang=0; ang<Math.PI*2; ang+=0.5) {
                    const tx = Math.round(startX + Math.cos(ang)*r);
                    const ty = Math.round(startY + Math.sin(ang)*r);
                    const pd = pCtx.getImageData(tx, ty, 1, 1).data;
                    if (pd[0] > 128) {
                        useX = tx; useY = ty;
                        found = true;
                        break;
                    }
                }
                if(found) break;
            }
            
            if(!found) {
                // å‘¨å›²ã‚‚å…¨éƒ¨åŸ‹ã¾ã£ã¦ã„ã‚‹ -> ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ãŒé«˜ã™ãã‚‹
                alert("éš™é–“åŸ‹ã‚ãƒ¬ãƒ™ãƒ«ãŒé«˜ã™ãã¦ã€ã“ã®éƒ¨å±‹ãŒå¡—ã‚Šã¤ã¶ã•ã‚Œã¦ã„ã¾ã™ã€‚\nå·¦ã®ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å€¤ã‚’å°‘ã—ä¸‹ã’ã¦ãã ã•ã„ã€‚");
                return;
            }
        }

        // æ¢ç´¢é–‹å§‹ (useX, useY ã‚’èµ·ç‚¹ã«ã™ã‚‹)
        const imgData = pCtx.getImageData(0, 0, w, h);
        const data = imgData.data;
        const mask = new Uint8Array(w * h);
        const stack = [useX, useY];
        
        let minX=w, maxX=0, minY=h, maxY=0;
        let pixelCount = 0;
        const LIMIT = w * h * 0.9;

        while(stack.length > 0) {
            const y = stack.pop();
            const x = stack.pop();
            const i = y * w + x;

            if(mask[i]) continue;
            mask[i] = 1;
            pixelCount++;
            
            if(x < minX) minX = x; if(x > maxX) maxX = x;
            if(y < minY) minY = y; if(y > maxY) maxY = y;

            if(pixelCount > LIMIT) break;

            // 4æ–¹å‘
            if(x+1<w && !mask[i+1] && data[(i+1)*4]>128) stack.push(x+1,y);
            if(x-1>=0 && !mask[i-1] && data[(i-1)*4]>128) stack.push(x-1,y);
            if(y+1<h && !mask[i+w] && data[(i+w)*4]>128) stack.push(x,y+1);
            if(y-1>=0 && !mask[i-w] && data[(i-w)*4]>128) stack.push(x,y-1);
        }

        if (pixelCount < 50) return;

        // è¼ªéƒ­æŠ½å‡º
        const boundaryPoints = traceBoundary(mask, w, h, minX, maxX, minY, maxY);
        if(boundaryPoints.length > 2) {
            addArea(boundaryPoints, 'auto');
        }
    }

    function traceBoundary(mask, w, h, minX, maxX, minY, maxY) {
        // ãƒã‚¹ã‚¯ã®é‡å¿ƒã‹ã‚‰RayCastã—ã¦è¼ªéƒ­ã‚’å–ã‚‹
        let cx=0, cy=0, count=0;
        // é«˜é€ŸåŒ–ã®ãŸã‚é–“å¼•ãã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
        for(let y=minY; y<=maxY; y+=4) {
            for(let x=minX; x<=maxX; x+=4) {
                if(mask[y*w+x]) { cx+=x; cy+=y; count++; }
            }
        }
        if(count===0) return [];
        cx /= count; cy /= count;

        const points = [];
        const rays = 72;
        for(let i=0; i<rays; i++) {
            const ang = (i/rays) * Math.PI * 2;
            const cos = Math.cos(ang);
            const sin = Math.sin(ang);
            
            // ä¸­å¿ƒã‹ã‚‰å¤–ã¸
            let r = 0;
            let lastX=cx, lastY=cy;
            
            // æœ€å¤§è·é›¢åˆ¶é™
            const maxR = Math.max(maxX-minX, maxY-minY) * 1.5;

            while(r < maxR) {
                r += 2;
                const tx = Math.round(cx + cos*r);
                const ty = Math.round(cy + sin*r);
                
                // ãƒã‚¹ã‚¯ç¯„å›²å¤–ã«å‡ºãŸã‚‰ã€ãã®ç›´å‰ãŒå£
                if(tx<minX || tx>maxX || ty<minY || ty>maxY || !mask[ty*w+tx]) {
                    points.push({x: lastX, y: lastY});
                    break;
                }
                lastX = tx; lastY = ty;
            }
        }
        return points;
    }

    function autoDetect() {
        if(!confirm("å…¨ã‚¨ãƒªã‚¢ã‚’æ¤œå‡ºã—ã¾ã™ã€‚æ•°ç§’ã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚")) return;
        const w = processingCanvas.width;
        const h = processingCanvas.height;
        const step = 40; 
        for(let y=step/2; y<h; y+=step) {
            for(let x=step/2; x<w; x+=step) {
                if(findAreaIndex({x,y}) === -1) {
                    // ã“ã“ã§ã¯ã‚¢ãƒ©ãƒ¼ãƒˆã‚’å‡ºã•ãªã„ã‚ˆã†ã«detectRoomAtã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç°¡ç•¥åˆ©ç”¨ã™ã‚‹ã‹
                    // try-catchçš„ã«å‘¼ã¶ã®ãŒè‰¯ã„ãŒã€å˜ç´”ã«å‘¼ã³å‡ºã™
                    // â€»å…¨è‡ªå‹•ã®å ´åˆã¯ã€ŒçœŸã£é»’åˆ¤å®šã€ãŒå‡ºã¦ã‚‚ç„¡è¦–ã—ã¦é€²ã‚€
                    const pData = pCtx.getImageData(x,y,1,1).data;
                    if(pData[0]>128) detectRoomAt(x, y);
                }
            }
        }
        draw();
        alert("å®Œäº†ã—ã¾ã—ãŸã€‚");
    }

    function addArea(points, method) {
        areas.push({ id: Date.now()+Math.random(), name: `Area ${areas.length+1}`, type: 'other', points: points });
        updateList(); draw();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (document.getElementById('showDebug').checked) {
            ctx.drawImage(processingCanvas, 0, 0);
            ctx.fillStyle="rgba(255,0,0,0.1)"; ctx.fillRect(0,0,canvas.width,canvas.height);
        } else if (img.src) {
            ctx.drawImage(img, 0, 0);
        }
        areas.forEach((area, idx) => {
            const isSel = idx === selectedAreaIndex;
            ctx.beginPath();
            area.points.forEach((p, i) => { if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y); });
            ctx.closePath();
            ctx.fillStyle = getColor(area.type); ctx.fill();
            ctx.strokeStyle = isSel ? 'blue' : '#666'; ctx.lineWidth = isSel ? 2 : 1; ctx.stroke();
            const c = getCenter(area.points);
            ctx.fillStyle="black"; ctx.font="11px sans-serif"; ctx.textAlign="center"; ctx.fillText(area.name, c.x, c.y);
        });
        if (currentPoints.length > 0) {
            ctx.beginPath(); currentPoints.forEach((p,i)=>{ if(i===0)ctx.moveTo(p.x,p.y);else ctx.lineTo(p.x,p.y);});
            ctx.strokeStyle='red'; ctx.lineWidth=2; ctx.stroke();
        }
    }

    function getPos(e) { const r=canvas.getBoundingClientRect(); return {x:(e.clientX-r.left)*(canvas.width/r.width), y:(e.clientY-r.top)*(canvas.height/r.height)}; }
    function findAreaIndex(p) {
        for(let i=areas.length-1; i>=0; i--) {
            const pts=areas[i].points; let inside=false;
            for(let j=0,k=pts.length-1; j<pts.length; k=j++){ if(((pts[j].y>p.y)!==(pts[k].y>p.y))&&(p.x<(pts[k].x-pts[j].x)*(p.y-pts[j].y)/(pts[k].y-pts[j].y)+pts[j].x)) inside=!inside; }
            if(inside) return i;
        } return -1;
    }
    function selectArea(i) {
        selectedAreaIndex=i; const a=areas[i];
        document.getElementById('roomName').value=a.name; document.getElementById('roomType').value=a.type;
        document.getElementById('attributeEditor').classList.remove('hidden'); draw();
    }
    function updateSelectedArea(){ if(selectedAreaIndex!==-1){ areas[selectedAreaIndex].name=document.getElementById('roomName').value; areas[selectedAreaIndex].type=document.getElementById('roomType').value; updateList(); draw(); }}
    function deleteSelectedArea(){ if(selectedAreaIndex!==-1){ areas.splice(selectedAreaIndex,1); selectedAreaIndex=-1; document.getElementById('attributeEditor').classList.add('hidden'); updateList(); draw(); }}
    function updateList(){
        const l=document.getElementById('areaList'); l.innerHTML='';
        areas.forEach((a,i)=>{ const d=document.createElement('div'); d.className='list-item'+(i===selectedAreaIndex?' selected':''); d.innerText=a.name; d.onclick=()=>selectArea(i); l.appendChild(d); });
    }
    function setMode(m){ mode=m; selectedAreaIndex=-1; draw(); }
    function getCenter(p){ let x=0,y=0; p.forEach(v=>{x+=v.x;y+=v.y}); return {x:x/p.length,y:y/p.length}; }
    function getColor(t){ const c={'classroom':'#4CAF5066','hallway':'#FFC10766'}; return c[t]||'#9E9E9E66'; }
    window.exportJSON=()=>{ document.getElementById('jsonOutput').value=JSON.stringify(areas.map(({id,...r})=>r),null,2); };
</script>
</body>
</html>
