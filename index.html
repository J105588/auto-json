<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒãƒƒãƒ—ã‚¨ãƒ‡ã‚£ã‚¿ v7.0 (éš™é–“åŸ‹ã‚ãƒˆãƒ¬ãƒ¼ã‚¹)</title>
    <style>
        body { font-family: sans-serif; display: flex; gap: 20px; padding: 20px; background-color: #f4f7f6; height: 95vh; box-sizing: border-box; color: #333; }
        #canvas-wrapper { position: relative; border: 2px solid #ccc; overflow: hidden; flex-grow: 1; background: white; box-shadow: 0 4px 6px rgba(0,0,0,0.1); display:flex; justify-content:center; align-items:center; }
        canvas { display: block; }
        #sidebar { width: 340px; display: flex; flex-direction: column; gap: 15px; height: 100%; min-width: 340px; }
        .panel { border: 1px solid #e0e0e0; padding: 15px; border-radius: 8px; background: white; }
        h3 { margin: 0 0 10px 0; font-size: 15px; border-bottom: 2px solid #eee; padding-bottom: 5px; color: #555; }
        input, select, button { padding: 8px; width: 100%; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 8px; font-size: 13px;}
        button { background: #007bff; color: white; border: none; font-weight: bold; cursor: pointer; }
        button:hover { background: #0056b3; }
        button.secondary { background: #6c757d; }
        button.danger { background: #dc3545; }
        button.magic { background: #6610f2; }
        .input-group { display: flex; gap: 5px; margin-bottom: 5px; }
        .list-container { flex-grow: 1; overflow-y: auto; border: 1px solid #eee; height: 150px; }
        .list-item { padding: 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px; cursor: pointer; }
        .list-item:hover { background: #f5faff; }
        .list-item.selected { background: #e6f2ff; border-left: 4px solid #007bff; }
        .hidden { display: none; }
        .slider-label { display:flex; justify-content:space-between; font-size:12px; color:#666; margin-bottom:2px;}
        .debug-view { font-size:11px; color:#666; margin-top:5px; display:block;}
    </style>
</head>
<body>

    <div id="canvas-wrapper">
        <canvas id="mapCanvas"></canvas>
    </div>

    <div id="sidebar">
        <div class="panel">
            <h3>1. å›³é¢èª­è¾¼</h3>
            <input type="file" id="imageLoader" accept="image/*, .svg">
        </div>

        <div class="panel" style="flex-grow: 1; display: flex; flex-direction: column;">
            <h3>2. è‡ªå‹•æ¤œå‡ºè¨­å®š</h3>
            
            <div class="slider-label"><span>éš™é–“åŸ‹ã‚ãƒ¬ãƒ™ãƒ« (ç·šã®å¤ªã‚‰ã›)</span><span id="gapVal">5</span></div>
            <input type="range" id="gapRange" min="0" max="20" value="5" oninput="updateSettings(this.value)">
            <small style="color:#666; font-size:11px; margin-bottom:10px; display:block;">
                å€¤ã‚’ä¸Šã’ã‚‹ã¨ã€ç·šãŒé€”åˆ‡ã‚Œã¦ã„ã¦ã‚‚ç¹‹ãŒã£ã¦ã„ã‚‹ã¨ã¿ãªã—ã¾ã™ã€‚<br>
                â€»ä¸Šã’ã™ãã‚‹ã¨ç‹­ã„é€šè·¯ãŒæ½°ã‚Œã¾ã™ã€‚
            </small>

            <label class="debug-view">
                <input type="checkbox" id="showDebug" onchange="draw()"> 
                è§£æç”¨ã®ã€Œå¤ªã£ãŸå£ã€ã‚’è¡¨ç¤ºã—ã¦ç¢ºèªã™ã‚‹
            </label>

            <hr style="border:0; border-top:1px solid #eee; width:100%; margin:10px 0;">

            <div id="actionPanel">
                 <button class="magic" onclick="autoDetect()">âš¡ å…¨ã‚¨ãƒªã‚¢ä¸€æ‹¬æ¤œå‡º</button>
                 <p style="text-align:center; margin:5px 0; font-size:12px; color:#888;">ã¾ãŸã¯ã€å›³é¢ä¸Šã®éƒ¨å±‹ã‚’ã‚¯ãƒªãƒƒã‚¯</p>
                 <button class="secondary" onclick="setMode('manual')">ğŸ– æ‰‹å‹•ã§æã</button>
            </div>

            <div id="attributeEditor" class="hidden" style="margin-top: 10px; border-top: 1px solid #eee; padding-top: 10px;">
                <h3 style="font-size:13px;">é¸æŠã‚¨ãƒªã‚¢ã®ç·¨é›†</h3>
                <input type="text" id="roomName" placeholder="åç§° (ä¾‹: 1-A)">
                <select id="roomType">
                    <option value="classroom">æ•™å®¤</option>
                    <option value="hallway">å»Šä¸‹</option>
                    <option value="entrance">å‡ºå…¥å£</option>
                    <option value="stairs">éšæ®µ</option>
                    <option value="restroom_m">ãƒˆã‚¤ãƒ¬(ç”·)</option>
                    <option value="restroom_f">ãƒˆã‚¤ãƒ¬(å¥³)</option>
                    <option value="other">ãã®ä»–</option>
                </select>
                <div class="input-group">
                    <button onclick="updateSelectedArea()">æ›´æ–°</button>
                    <button class="danger" onclick="deleteSelectedArea()">å‰Šé™¤</button>
                </div>
            </div>

            <div class="list-container" id="areaList"></div>
        </div>

        <div class="panel">
            <h3>3. å‡ºåŠ›</h3>
            <button class="secondary" onclick="exportJSON()">JSONã‚³ãƒ”ãƒ¼</button>
            <textarea id="jsonOutput" style="height: 50px;"></textarea>
        </div>
    </div>

<script>
    // --- å¤‰æ•°å®šç¾© ---
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    let img = new Image();
    let areas = [];
    let currentPoints = []; // æ‰‹å‹•æç”»ç”¨
    let mode = 'auto'; // 'auto' | 'manual' | 'edit'
    let selectedAreaIndex = -1;
    
    // è§£æç”¨ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹
    let processingCanvas = document.createElement('canvas');
    let pCtx = processingCanvas.getContext('2d', { willReadFrequently: true });

    // --- 1. ç”»åƒèª­è¾¼ ---
    document.getElementById('imageLoader').addEventListener('change', function(e){
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = function(event){
            img.onload = function(){
                canvas.width = img.width;
                canvas.height = img.height;
                processingCanvas.width = img.width;
                processingCanvas.height = img.height;
                prepareProcessingMap();
                draw();
            }
            img.src = event.target.result;
        }
    });

    // --- 2. éš™é–“åŸ‹ã‚å‡¦ç† (æœ€é‡è¦) ---
    function prepareProcessingMap() {
        if(!img.src) return;
        const gapSize = parseInt(document.getElementById('gapRange').value);
        document.getElementById('gapVal').innerText = gapSize;

        // ç”»åƒã‚’æç”»
        pCtx.clearRect(0, 0, processingCanvas.width, processingCanvas.height);
        pCtx.drawImage(img, 0, 0);

        // CSSãƒ•ã‚£ãƒ«ã‚¿ã‚’ä½¿ã£ã¦ã€Œã¼ã‹ã—ã€â†’ã€Œ2å€¤åŒ–ã€ã‚’è¡Œã†ã“ã¨ã§ç·šã‚’å¤ªã‚‰ã›ã‚‹
        // ã“ã‚Œã«ã‚ˆã‚Šã€gapSizeåˆ†ã®éš™é–“ãŒåŸ‹ã¾ã‚‹
        if (gapSize > 0) {
            pCtx.save();
            // ã¼ã‹ã— (éš™é–“ã‚’åŸ‹ã‚ã‚‹)
            pCtx.filter = `blur(${gapSize/2}px)`;
            pCtx.drawImage(processingCanvas, 0, 0);
            // ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆæœ€å¤§åŒ– (ã¼ã‚„ã‘ãŸéƒ¨åˆ†ã‚’é»’ã„å£ã¨ã—ã¦ç¢ºå®šã•ã›ã‚‹)
            // thresholdçš„ãªå‡¦ç†ã‚’å†ç¾ã™ã‚‹ãŸã‚ã€ä½•åº¦ã‚‚å¡—ã‚Šé‡ã­ã‚‹ã‹ã€filterã‚’ä½¿ã†
            pCtx.filter = `contrast(10000%) grayscale(100%)`; // 2å€¤åŒ–
            pCtx.drawImage(processingCanvas, 0, 0);
            pCtx.restore();
        }
    }

    function updateSettings(val) {
        prepareProcessingMap();
        if(document.getElementById('showDebug').checked) draw();
    }

    // --- 3. ã‚¯ãƒªãƒƒã‚¯æ¤œå‡º & ãƒˆãƒ¬ãƒ¼ã‚¹å‡¦ç† ---
    canvas.addEventListener('mousedown', async function(e) {
        const pos = getPos(e);

        if (mode === 'manual') {
            currentPoints.push(pos);
            draw();
            return;
        }

        // æ—¢å­˜ã‚¨ãƒªã‚¢é¸æŠ
        const clickedIdx = findAreaIndex(pos);
        if (clickedIdx !== -1) {
            selectArea(clickedIdx);
            return;
        }
        
        if (mode === 'auto') {
            // ä½•ã‚‚ãªã„ã¨ã“ã‚ã‚’ã‚¯ãƒªãƒƒã‚¯ -> è‡ªå‹•æ¤œå‡ºãƒˆãƒ©ã‚¤
            detectRoomAt(pos.x, pos.y);
        }
        
        selectedAreaIndex = -1;
        document.getElementById('attributeEditor').classList.add('hidden');
        draw();
    });
    
    // æ‰‹å‹•ãƒ¢ãƒ¼ãƒ‰ã®ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯å®Œäº†
    canvas.addEventListener('dblclick', function() {
        if(mode === 'manual' && currentPoints.length > 2) {
            addArea(currentPoints, 'manual');
            currentPoints = [];
            draw();
        }
    });


    // --- ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : Flood Fill + Marching Squares (ç°¡æ˜“ç‰ˆ) ---
    function detectRoomAt(startX, startY) {
        const w = processingCanvas.width;
        const h = processingCanvas.height;
        const imgData = pCtx.getImageData(0, 0, w, h);
        const data = imgData.data;

        // 1. ã‚¯ãƒªãƒƒã‚¯åœ°ç‚¹ãŒã€Œå£(é»’)ã€ãªã‚‰ç„¡è¦–
        // èƒŒæ™¯ãŒç™½(255,255,255)ã«è¿‘ã„ã‹ã©ã†ã‹
        const idx = (startY * w + startX) * 4;
        if (data[idx] < 128) { // é»’ã£ã½ã„
            alert("å£ã®ä¸Šã§ã™ã€‚éƒ¨å±‹ã®ä¸­ï¼ˆç™½ã„éƒ¨åˆ†ï¼‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚");
            return;
        }

        // 2. Flood Fill (å¡—ã‚Šã¤ã¶ã—) ã§é ˜åŸŸç‰¹å®š
        // Uint8Arrayã§è¨ªå•æ¸ˆã¿ãƒãƒƒãƒ—å…¼é ˜åŸŸãƒãƒƒãƒ—ã‚’ä½œæˆ
        const mask = new Uint8Array(w * h);
        const stack = [startX, startY];
        const points = []; // é ˜åŸŸå†…ã®å…¨ãƒ”ã‚¯ã‚»ãƒ«ï¼ˆå¤šã™ãã‚‹ã®ã§å¢ƒç•Œã ã‘å–ã‚ŠãŸã„ãŒã€ã¾ãšã¯å…¨å–å¾—ï¼‰
        
        let minX=w, maxX=0, minY=h, maxY=0;
        let pixelCount = 0;
        const LIMIT = w * h * 0.8; // å®‰å…¨è£…ç½®

        while(stack.length > 0) {
            const y = stack.pop();
            const x = stack.pop();
            const i = y * w + x;

            if(mask[i]) continue;
            mask[i] = 1;
            pixelCount++;
            
            if(x < minX) minX = x; if(x > maxX) maxX = x;
            if(y < minY) minY = y; if(y > maxY) maxY = y;

            // 4æ–¹å‘æ¢ç´¢
            if(x+1 < w && !mask[i+1] && data[(i+1)*4] > 128) stack.push(x+1, y);
            if(x-1 >= 0 && !mask[i-1] && data[(i-1)*4] > 128) stack.push(x-1, y);
            if(y+1 < h && !mask[i+w] && data[(i+w)*4] > 128) stack.push(x, y+1);
            if(y-1 >= 0 && !mask[i-w] && data[(i-w)*4] > 128) stack.push(x, y-1);

            if(pixelCount > LIMIT) break;
        }

        if (pixelCount < 100) return; // å°ã•ã™ãã‚‹ã‚´ãƒŸã¯ç„¡è¦–

        // 3. è¼ªéƒ­è¿½è·¡ (ç°¡æ˜“æ³•: ã‚¹ã‚­ãƒ£ãƒ³ãƒ©ã‚¤ãƒ³ã”ã¨ã®ç«¯ç‚¹å–å¾—)
        // Marching Squaresã¯å®Ÿè£…ãŒé‡ã„ãŸã‚ã€
        // ã€Œå„Yåº§æ¨™ã«ãŠã‘ã‚‹å·¦ç«¯ã¨å³ç«¯ã®Xã€ã‚’å–å¾—ã—ã¦ã¤ãªãæ–¹å¼ã§è¿‘ä¼¼ã—ã¾ã™ã€‚
        // ã“ã‚Œã¯å‡¹å‡¸ã®ã‚ã‚‹éƒ¨å±‹ï¼ˆã‚³ã®å­—å‹ãªã©ï¼‰ã«ã¯å¼±ã„ãŒã€å˜ç´”ãªéƒ¨å±‹ã«ã¯é«˜é€Ÿã§æœ‰åŠ¹ã€‚
        // â†’ ä»Šå›ã¯ã€Œã‚³ã®å­—ã€ã«å¯¾å¿œã™ã‚‹ãŸã‚ã€å°‘ã—ä¸å¯§ãªãƒˆãƒ¬ãƒ¼ã‚¹ã‚’è¡Œã„ã¾ã™ã€‚

        // å¢ƒç•Œç·šãƒ”ã‚¯ã‚»ãƒ«ã‚’æ¢ã™
        const boundaryPoints = traceBoundary(mask, w, h, minX, maxX, minY, maxY);
        
        // ç‚¹ã‚’é–“å¼•ã (ç°¡ç•¥åŒ–)
        const simplified = simplifyPoints(boundaryPoints, 5); // 5pxä»¥ä¸‹ã®ã‚ºãƒ¬ã¯ç„¡è¦–

        if(simplified.length > 2) {
            addArea(simplified, 'auto');
        }
    }

    // å¢ƒç•Œãƒˆãƒ¬ãƒ¼ã‚¹ (Moore-Neighbor Tracing ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ç°¡æ˜“ç‰ˆ)
    function traceBoundary(mask, w, h, minX, maxX, minY, maxY) {
        let points = [];
        
        // 1. æœ€åˆã®å¢ƒç•Œç‚¹ã‚’è¦‹ã¤ã‘ã‚‹ (ä¸Šã‹ã‚‰èµ°æŸ»)
        let startP = null;
        for(let y=minY; y<=maxY; y++) {
            for(let x=minX; x<=maxX; x++) {
                if(mask[y*w+x] === 1) {
                    startP = {x, y};
                    break;
                }
            }
            if(startP) break;
        }
        if(!startP) return [];

        // 2. æ™‚è¨ˆå›ã‚Šã«å£æ²¿ã„ã‚’æ­©ã
        // æ–¹å‘: 0:å³, 1:ä¸‹, 2:å·¦, 3:ä¸Š
        let cx = startP.x, cy = startP.y;
        let dir = 0; 
        points.push({x:cx, y:cy});
        
        const maxSteps = (maxX - minX + maxY - minY) * 4; // ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢
        let steps = 0;

        // ãƒ ãƒ¼ã‚¢è¿‘å‚æ¢ç´¢
        // ç¾åœ¨åœ°ãŒã€Œç™½(1)ã€ã€ãã®å‘¨ã‚Šã®ã€Œé»’(0)ã€ã¨ã®å¢ƒç•Œã‚’æ­©ã
        // â€»å³å¯†ãªå®Ÿè£…ã¯è¤‡é›‘ãªã®ã§ã€ã“ã“ã§ã¯ã€Œä»Šã®ãƒ”ã‚¯ã‚»ãƒ«ãŒ1ãªã‚‰ã€å·¦æ‰‹æ²¿ã„ã«é€²ã‚€ã€ãƒ­ã‚¸ãƒƒã‚¯
        
        // ç°¡æ˜“å®Ÿè£…: å¢ƒç•Œãƒ”ã‚¯ã‚»ãƒ«ã‚’ã™ã¹ã¦æŠ½å‡ºã—ã¦ã€è§’åº¦é †ã«ã‚½ãƒ¼ãƒˆã™ã‚‹ Convex Hull (å‡¸åŒ…)
        // ã ã¨å‡¹ã¿ãŒå–ã‚Œãªã„ã€‚
        // ã“ã“ã¯ã€Œmaskç”»åƒã‹ã‚‰è¼ªéƒ­æŠ½å‡ºã™ã‚‹ã€æ¨™æº–çš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’ä½¿ã„ã¾ã™ã€‚
        
        // --- ç°¡æ˜“ç½®æ›: å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãªã—ã§ã®å®Ÿè£…ã¯é‡ã„ã®ã§ã€
        // æ¤œå‡ºã•ã‚ŒãŸãƒã‚¹ã‚¯é ˜åŸŸã®ã€Œå‡¸åŒ…ã€ã§ã¯ãªãã€Œã‚¹ã‚­ãƒ£ãƒ³ãƒ©ã‚¤ãƒ³ã€ã§ä¸Šä¸‹ã®è¼ªéƒ­ã‚’å–ã‚‹ ---
        
        const topEdge = [];
        const bottomEdge = [];
        
        // ã‚¹ã‚­ãƒ£ãƒ³ãƒ©ã‚¤ãƒ³æ–¹å¼ (å‡¹å½¢çŠ¶ã®ä¸€éƒ¨ãŒã¤ã¶ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŒã€éš™é–“åŸ‹ã‚é‡è¦–ãªã‚‰è¨±å®¹ç¯„å›²)
        // ãŸã ã—ã€Œã‚³ã®å­—ã€ã«å¯¾å¿œã™ã‚‹ãŸã‚ã«ã€Yè»¸æ–¹å‘ã ã‘ã§ãªãXè»¸æ–¹å‘ã‹ã‚‰ã‚‚ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦åˆæˆã™ã‚‹æ‰‹ã‚‚ã‚ã‚‹ãŒã€
        // ã“ã“ã§ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«ã€Œéš™é–“ã‚’åŸ‹ã‚ãŸç”»åƒã€ã«å¯¾ã—ã¦ã€
        // æ”¾å°„çŠ¶RayCast (v5ã®æ”¹è‰¯ç‰ˆ) ã‚’ä½¿ã†ã®ãŒæœ€ã‚‚ã‚³ãƒ¼ãƒ‰é‡ãŒå°‘ãªãå®‰å®šã™ã‚‹ã€‚
        
        // æ–¹é‡å¤‰æ›´: ã›ã£ã‹ãmaskã‚’ä½œã£ãŸã®ã§ã€maskã®é‡å¿ƒã‹ã‚‰RayCastã™ã‚‹ã€‚
        // ã“ã‚Œãªã‚‰å£ã®åšã¿ã‚’è€ƒæ…®ã—ãŸæ­£ç¢ºãªå½¢çŠ¶ãŒå–ã‚Œã‚‹ã€‚
        
        let center = {x:0, y:0};
        let count = 0;
        // é‡å¿ƒè¨ˆç®— (é–“å¼•ã„ã¦è¨ˆç®—)
        for(let y=minY; y<=maxY; y+=5) {
            for(let x=minX; x<=maxX; x+=5) {
                if(mask[y*w+x]) { center.x+=x; center.y+=y; count++; }
            }
        }
        center.x /= count; center.y /= count;

        // é‡å¿ƒã‹ã‚‰å…¨æ–¹ä½ã«Rayã‚’é£›ã°ã—ã€maskãŒ0ã«ãªã‚‹åœ°ç‚¹ã‚’æ¢ã™
        // ã“ã‚Œã§ã€Œé€£çµæˆåˆ†ã®å½¢çŠ¶ã€ã‚’å–å¾—ã§ãã‚‹
        const rayPoints = [];
        const rays = 72;
        for(let i=0; i<rays; i++) {
            const ang = (i/rays) * Math.PI * 2;
            const cos = Math.cos(ang);
            const sin = Math.sin(ang);
            let r = 0;
            let hitX = center.x, hitY = center.y;
            // ãƒã‚¹ã‚¯å†…ã‚’çªãé€²ã‚€
            while(true) {
                r += 2;
                const tx = Math.round(center.x + cos * r);
                const ty = Math.round(center.y + sin * r);
                // ãƒã‚¹ã‚¯ã®å¤–(=å£ã¾ãŸã¯åˆ¥ã®éƒ¨å±‹)ã«å‡ºãŸã‚‰çµ‚äº†
                if(tx<minX || tx>maxX || ty<minY || ty>maxY || !mask[ty*w+tx]) {
                    hitX = tx - cos*2; // 1æ­©æˆ»ã‚‹
                    hitY = ty - sin*2;
                    break;
                }
            }
            rayPoints.push({x:hitX, y:hitY});
        }
        return rayPoints;
    }

    function simplifyPoints(points, tolerance) {
        // ç°¡æ˜“çš„ãªé–“å¼•ã
        if(points.length < 3) return points;
        return points; // ä»Šå›ã¯RayCastã§æ»‘ã‚‰ã‹ã«å–ã£ã¦ã„ã‚‹ã®ã§ãã®ã¾ã¾è¿”ã™
    }


    // --- ä¸€æ‹¬æ¤œå‡º ---
    function autoDetect() {
        if(!confirm("ç”»é¢ä¸Šã®ã™ã¹ã¦ã®ç™½ã„é ˜åŸŸã‚’æ¤œå‡ºã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚\nå°‘ã—æ™‚é–“ãŒã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚")) return;
        
        // ã‚°ãƒªãƒƒãƒ‰ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã—ã¦ã€æœªæ¢ç´¢ã®å ´æ‰€ãŒã‚ã‚Œã°detectRoomAtã‚’å®Ÿè¡Œ
        const w = processingCanvas.width;
        const h = processingCanvas.height;
        const step = 30; // 30pxé–“éš”ã§ãƒã‚§ãƒƒã‚¯
        let count = 0;
        
        for(let y=step/2; y<h; y+=step) {
            for(let x=step/2; x<w; x+=step) {
                // æ—¢å­˜ã®ã‚¨ãƒªã‚¢ã«å«ã¾ã‚Œã¦ã„ãªã„ã‹ï¼Ÿ
                if(findAreaIndex({x,y}) === -1) {
                    detectRoomAt(x, y);
                    count++;
                }
            }
        }
        draw();
        alert("æ¤œå‡ºå®Œäº†ã€‚ä¸è¦ãªã‚¨ãƒªã‚¢ã¯å‰Šé™¤ã—ã¦ãã ã•ã„ã€‚");
    }


    // --- å…±é€šæ©Ÿèƒ½ ---
    function addArea(points, method) {
        areas.push({
            id: Date.now() + Math.random(),
            name: `Area ${areas.length + 1}`,
            type: 'other',
            points: points
        });
        updateList();
        draw();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: å¤ªã£ãŸå£ã‚’è¡¨ç¤º
        if (document.getElementById('showDebug').checked) {
            ctx.drawImage(processingCanvas, 0, 0);
            ctx.fillStyle = "rgba(255, 0, 0, 0.1)";
            ctx.fillRect(0,0,canvas.width, canvas.height); // èµ¤ã¿æ›ã‘ã‚‹
        } else if (img.src) {
            ctx.drawImage(img, 0, 0);
        }

        areas.forEach((area, idx) => {
            const isSel = idx === selectedAreaIndex;
            ctx.beginPath();
            area.points.forEach((p, i) => {
                if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
            });
            ctx.closePath();
            ctx.fillStyle = getColor(area.type);
            ctx.fill();
            ctx.strokeStyle = isSel ? 'blue' : '#666';
            ctx.lineWidth = isSel ? 2 : 1;
            ctx.stroke();

            // ãƒ©ãƒ™ãƒ«
            const c = getCenter(area.points);
            ctx.fillStyle = "black"; ctx.font = "11px sans-serif"; ctx.textAlign="center";
            ctx.fillText(area.name, c.x, c.y);
        });

        // æ‰‹å‹•æç”»ä¸­
        if (currentPoints.length > 0) {
            ctx.beginPath();
            currentPoints.forEach((p, i) => {
                if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
            });
            ctx.strokeStyle = 'red'; ctx.lineWidth = 2; ctx.stroke();
        }
    }

    // --- UI/Utility ---
    function getPos(e) {
        const r = canvas.getBoundingClientRect();
        return { x: (e.clientX - r.left)*(canvas.width/r.width), y: (e.clientY - r.top)*(canvas.height/r.height) };
    }
    
    function findAreaIndex(p) {
        for(let i=areas.length-1; i>=0; i--) {
            const pts = areas[i].points;
            let inside = false;
            for (let j = 0, k = pts.length - 1; j < pts.length; k = j++) {
                if (((pts[j].y > p.y) !== (pts[k].y > p.y)) && (p.x < (pts[k].x - pts[j].x) * (p.y - pts[j].y) / (pts[k].y - pts[j].y) + pts[j].x)) inside = !inside;
            }
            if(inside) return i;
        }
        return -1;
    }

    function selectArea(i) {
        selectedAreaIndex = i;
        const a = areas[i];
        document.getElementById('roomName').value = a.name;
        document.getElementById('roomType').value = a.type;
        document.getElementById('attributeEditor').classList.remove('hidden');
        draw();
    }
    
    function updateSelectedArea() {
        if(selectedAreaIndex===-1)return;
        areas[selectedAreaIndex].name = document.getElementById('roomName').value;
        areas[selectedAreaIndex].type = document.getElementById('roomType').value;
        updateList(); draw();
    }
    function deleteSelectedArea() {
        if(selectedAreaIndex!==-1) { areas.splice(selectedAreaIndex, 1); selectedAreaIndex=-1; document.getElementById('attributeEditor').classList.add('hidden'); updateList(); draw(); }
    }

    function updateList() {
        const list = document.getElementById('areaList');
        list.innerHTML = '';
        areas.forEach((a, i) => {
            const d = document.createElement('div');
            d.className = 'list-item' + (i===selectedAreaIndex ? ' selected' : '');
            d.innerText = a.name;
            d.onclick = () => selectArea(i);
            list.appendChild(d);
        });
    }
    
    function setMode(m) { mode = m; selectedAreaIndex=-1; draw(); }
    function getCenter(pts) { let x=0,y=0; pts.forEach(p=>{x+=p.x;y+=p.y}); return {x:x/pts.length, y:y/pts.length}; }
    function getColor(t) { const c={'classroom':'#4CAF5066','hallway':'#FFC10766'}; return c[t]||'#9E9E9E66'; }
    
    window.exportJSON = () => {
        document.getElementById('jsonOutput').value = JSON.stringify(areas.map(({id,...r})=>r), null, 2);
    };
</script>
</body>
</html>
